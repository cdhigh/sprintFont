#!/usr/bin/env python3
# -*- coding:utf-8 -*-
"""Sprint-Layout的PCB导出为kicad PCB文件
比Gerber要好, 能保留大部分可编辑信息, 但是不完美, 因为没有网表
Author: cdhigh <https://github.com/cdhigh>
"""
import datetime, uuid
from .kicad_definitions import *
from sprint_struct.sprint_textio import *

def uuid4():
    return str(uuid.uuid4())

#保留小数位数的同时,能处理一些None或非法值之类的,比如{var:.2f}健壮
def r2(value):
    try:
        return round(value, 2)
    except:
        return 0

class KicadGenerator:
    #textIo: SprintTextIO对象
    def __init__(self, textIo):
        self.textIo = textIo
        self._componentNo = 0

    def compNo(self):
        self._componentNo += 1
        return self._componentNo
    
    #导出到KICAD的主接口, 失败返回错误信息
    def generate(self, outputFile):
        try:
            with open(outputFile, 'w', encoding='utf-8') as f:
                self.writeHeader(f)
                self.writeLayers(f)
                self.writeSetup(f)
                self.writeNetlist(f)
                self.writeElements(f)
                self.writeFooter(f)
            return ''
        except Exception as e:
            return str(e)

    #Get KiCad layer name from Sprint layer index
    def getLayerName(self, layerIdx):
        return sprintLayerMap.get(layerIdx, "Dwgs.User")

    def writeHeader(self, f):
        dateStr = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        f.write('(kicad_pcb\n')
        f.write('  (version 20241229)\n')
        f.write('  (generator "sprint_converter")\n')
        f.write('  (generator_version "9.0")\n')
        f.write('  (general\n')
        f.write('    (thickness 1.6)\n')
        f.write('    (legacy_teardrops no)\n')
        f.write('  )\n')
        f.write('  (paper "A4")\n')
        f.write('  (title_block\n')
        f.write('    (title "Converted from Sprint-Layout v6.0")\n')
        f.write(f'    (date "{dateStr}")\n')
        f.write('    (comment 1 "Generated by sprintFont")\n')
        f.write('  )\n')

    def writeLayers(self, f):
        f.write('  (layers\n')
        f.write('    (0 "F.Cu" signal)\n')
        f.write('    (31 "B.Cu" signal)\n')
        f.write('    (32 "B.Adhes" user "B.Adhesive")\n')
        f.write('    (33 "F.Adhes" user "F.Adhesive")\n')
        f.write('    (34 "B.Paste" user)\n')
        f.write('    (35 "F.Paste" user)\n')
        f.write('    (36 "B.SilkS" user "B.Silkscreen")\n')
        f.write('    (37 "F.SilkS" user "F.Silkscreen")\n')
        f.write('    (38 "B.Mask" user)\n')
        f.write('    (39 "F.Mask" user)\n')
        f.write('    (40 "Dwgs.User" user "User.Drawings")\n')
        f.write('    (41 "Cmts.User" user "User.Comments")\n')
        f.write('    (42 "Eco1.User" user "User.Eco1")\n')
        f.write('    (43 "Eco2.User" user "User.Eco2")\n')
        f.write('    (44 "Edge.Cuts" user)\n')
        f.write('    (45 "Margin" user)\n')
        f.write('    (46 "B.CrtYd" user "B.Courtyard")\n')
        f.write('    (47 "F.CrtYd" user "F.Courtyard")\n')
        f.write('    (48 "B.Fab" user)\n')
        f.write('    (49 "F.Fab" user)\n')
        f.write('  )\n')

    def writeSetup(self, f):
        f.write('  (setup\n')
        f.write('    (pad_to_mask_clearance 0)\n')
        f.write('    (allow_soldermask_bridges_in_footprints no)\n')
        f.write('    (tenting front back)\n')
        f.write('    (pcbplotparams\n')
        f.write('      (layerselection 0x00010fc_ffffffff)\n')
        f.write('      (plot_on_all_layers_selection 0x0000000_00000000)\n')
        f.write('      (disableapertmacros no)\n')
        f.write('      (usegerberextensions no)\n')
        f.write('      (usegerberattributes yes)\n')
        f.write('      (usegerberadvancedattributes yes)\n')
        f.write('      (creategerberjobfile yes)\n')
        f.write('      (dashed_line_dash_ratio 12.000000)\n')
        f.write('      (dashed_line_gap_ratio 3.000000)\n')
        f.write('      (svgprecision 4)\n')
        f.write('      (plotframeref no)\n')
        f.write('      (mode 1)\n')
        f.write('      (useauxorigin no)\n')
        f.write('      (hpglpennumber 1)\n')
        f.write('      (hpglpenspeed 20)\n')
        f.write('      (hpglpendiameter 15.000000)\n')
        f.write('      (pdf_front_fp_property_popups yes)\n')
        f.write('      (pdf_back_fp_property_popups yes)\n')
        f.write('      (pdf_metadata yes)\n')
        f.write('      (pdf_single_document no)\n')
        f.write('      (dxfpolygonmode yes)\n')
        f.write('      (dxfimperialunits yes)\n')
        f.write('      (dxfusepcbnewfont yes)\n')
        f.write('      (psnegative no)\n')
        f.write('      (psa4output no)\n')
        f.write('      (plot_black_and_white yes)\n')
        f.write('      (sketchpadsonfab no)\n')
        f.write('      (plotpadnumbers no)\n')
        f.write('      (hidednponfab no)\n')
        f.write('      (sketchdnponfab yes)\n')
        f.write('      (crossoutdnponfab yes)\n')
        f.write('      (subtractmaskfromsilk no)\n')
        f.write('      (outputformat 1)\n')
        f.write('      (mirror no)\n')
        f.write('      (drillshape 1)\n')
        f.write('      (scaleselection 1)\n')
        f.write('      (outputdirectory "")\n')
        f.write('    )\n')
        f.write('  )\n')

    def writeNetlist(self, f):
        f.write('  (net 0 "")\n')
        f.write('  (embedded_fonts no)\n')

    def writeElements(self, f):
        self._processGroup(f, self.textIo)

    def _processGroup(self, f, group, centroid=(0,0)):
        padNo = 0
        for elem in group.elements:
            if isinstance(elem, SprintTrack):
                self._writeTrack(f, elem, centroid)
            elif isinstance(elem, SprintPad):
                padNo += 1
                self._writePad(f, elem, centroid, padNo)
            elif isinstance(elem, SprintPolygon):
                self._writeZone(f, elem, centroid)
            elif isinstance(elem, SprintText):
                self._writeText(f, elem, centroid)
            elif isinstance(elem, SprintCircle):
                self._writeCircle(f, elem, centroid)
            elif isinstance(elem, SprintGroup):
                self._processGroup(f, elem, centroid)
            elif isinstance(elem, SprintComponent):
                self._writeComponent(f, elem)

    #写导线,kicad的每个转折点都要一个单独的segment,靠网表和首尾坐标相互连接,kicad快捷键为U
    #格式: (segment (start x y) (end x y) (width w) (layer Name) (net 0) (uuid UUID))
    #或 (fp_line (start x y) (end x y) (stroke (width w) (type solid)) (layer Name) (uuid UUID))
    #或 (gr_line (start x y) (end x y) (stroke (width w) (type solid)) (layer Name) (uuid UUID))
    #注意: 网络只有数字标识没有名字, uuid名字也可以是tstamp
    #f: 文件句柄
    #track: SprintTrack实例
    #centroid: 所属元件(footprint)的几何中心, =(0,0)为孤立元素
    def _writeTrack(self, f, track, centroid=(0,0)):
        points = track.points
        if len(points) < 2:
            return

        space = '  ' if centroid == (0,0) else '    '

        layer = self.getLayerName(track.layerIdx)
        if centroid != (0,0): #封装内不管是导线还是绘图线都使用fp_line
            name = 'fp_line'
            width = f'(stroke (width {r2(track.width)}) (type solid))'
            net = ''
        elif track.layerIdx in (LAYER_S1, LAYER_S2, LAYER_U): #kicad导线和绘图线是分开的
            name = 'gr_line'
            width = f'(stroke (width {r2(track.width)}) (type solid))'
            net = ''
        else:
            name = 'segment'
            width = f'(width {r2(track.width)})'
            net = '(net 0) '

        for i in range(len(points) - 1):
            p1 = points[i]
            p2 = points[i + 1]
            x1, y1 = r2(p1[0] - centroid[0]), r2(p1[1] - centroid[1])
            x2, y2 = r2(p2[0] - centroid[0]), r2(p2[1] - centroid[1])
            f.write(f'{space}({name} (start {x1} {y1}) (end {x2} {y2}) '
                   f'{width} (layer {layer}) {net}(uuid {uuid4()}))\n')

    #转换焊盘,kicad不允许孤立焊盘存在,必须依附于某个footprint,
    #如果没有外层footprint, 这里需要创建一个footprint包裹焊盘
    #centroid: 所属元件(footprint)的几何中心, =(0,0)为孤立元素
    #padNo: 在元件内的焊盘序号, 从1开始
    def _writePad(self, f, pad, centroid=(0,0), padNo=1):
        layer = self.getLayerName(pad.layerIdx)
        rotation = sprintAngleToKicad(pad.rotation)
        sizeX = r2(max(pad.size, 0.1) if pad.sizeX == 0 else pad.sizeX)
        sizeY = r2(max(pad.size, 0.1) if pad.sizeY == 0 else pad.sizeY)
        x, y = r2(pad.pos[0] - centroid[0]), r2(pad.pos[1] - centroid[1])

        # 通孔焊盘
        if pad.padType == 'PAD':
            padType = "thru_hole"
            if pad.via:
                padLayers = "*.Cu *.Mask"
            elif pad.layerIdx == LAYER_C1:
                padLayers = "F.Cu F.Mask"
            else:
                padLayers = "B.Cu B.Mask"
            drillDef = f'(drill {r2(pad.drill)})'
            if pad.form == PAD_FORM_SQUARE:
                shape = "rect"
            elif pad.form in (PAD_FORM_RECT_ROUND_H, PAD_FORM_RECT_ROUND_V):
                shape = "oval"
            else:
                shape = "circle"
        else: #贴片焊盘
            padType = "smd"
            if layer.endswith(".Cu"):
                padLayers = f'{layer} {layer.replace(".Cu", ".Mask")} {layer.replace(".Cu", ".Paste")}'
            else:
                padLayers = layer
            drillDef = ""
            shape = "rect"
        
        if centroid == (0,0): #创建一个footprint包括孤立焊盘
            compNo = self.compNo()
            fpId = f"Pad_{int(x * 100)}_{int(y * 100)}_{compNo}"
            f.write(f'  (footprint "{fpId}" (layer "{layer}")\n')
            f.write(f'    (at {x} {y} 0) (uuid {uuid4()})\n')
            f.write(f'    (property "Reference" "CMP{compNo}" (at 0 0 0) (layer "{layer}") (hide yes) (uuid {uuid4()}) (effects (font (size 1 1) (thickness 0.15))))\n')
            f.write(f'    (property "Value" "" (at 0 0 0) (layer "{layer.replace(".Cu", ".Fab")}") (hide yes) (uuid {uuid4()}) (effects (font (size 1 1) (thickness 0.15))))\n')
            f.write(f'    (property "Footprint" "" (at 0 0 0) (unlocked yes) (layer "{layer.replace(".Cu", ".Fab")}") (hide yes) (uuid {uuid4()}) (effects (font (size 1 1) (thickness 0.15))))\n')
            f.write('    (attr smd)\n' if padType == "smd" else '    (attr through_hole)\n')
            #rotation写在外层会导致旋转失效
            f.write(f'    (pad "1" {padType} {shape} (at 0 0 {rotation}) (size {sizeX} {sizeY}) '
                   f'{drillDef} (layers {padLayers}) (net 0 "") (uuid {uuid4()}))\n')
            f.write(f'  )\n')
        else:
            f.write(f'    (pad "{padNo}" {padType} {shape} (at {x} {y} {rotation}) (size {sizeX} {sizeY}) '
                   f'{drillDef} (layers {padLayers}) (net 0 "") (uuid {uuid4()}))\n')

    #转换多边形区域
    #格式: (zone (net 0) (net_name "") (layer LayerName) (uuid UUID) (hatch edge 0.5)...)
    #或 (fp_poly (pts (xy X Y)...) (layer LayerName) (stroke (width w) (type solid)) (fill yes) (uuid UUID))
    #centroid: 所属元件(footprint)的几何中心, =(0,0)为孤立元素
    def _writeZone(self, f, zone, centroid=(0,0)):
        layer = self.getLayerName(zone.layerIdx)
        if centroid == (0,0):
            f.write(f'  (zone (net 0) (net_name "") (layer {layer}) (uuid {uuid4()}) (hatch edge 0.5)\n')
            f.write(f'    (connect_pads (clearance {zone.clearance}))\n')
            if zone.cutout: #禁止铺铜区
                f.write('    (min_thickness 0.1) (filled_areas_thickness no)\n')
                f.write('    (keepout (tracks allowed) (vias allowed) (pads allowed)'
                        ' (copperpour not_allowed) (footprints allowed))\n')
            else:
                f.write('    (min_thickness 0.254) (filled_areas_thickness no)\n')
            f.write('    (fill yes (thermal_gap 0.5) (thermal_bridge_width 0.5))\n')
            f.write('    (polygon\n')
            f.write('      (pts\n')
            for p in zone.points:
                f.write(f'        (xy {r2(p[0] - centroid[0])} {r2(p[1] - centroid[1])})\n')
            f.write('      )\n')
            f.write('    )\n')
            f.write('  )\n')
        else:
            #封装内的禁止铺铜区不能在铜层创建多边形, 否则会短路
            if zone.cutout and layer.endswith('.Cu'):
                layer = "Cmts.User"
            f.write('    (fp_poly\n')
            f.write('      (pts\n')
            for p in zone.points:
                f.write(f'        (xy {r2(p[0] - centroid[0])} {r2(p[1] - centroid[1])})\n')
            f.write('      )\n')
            f.write(f'      (layer {layer}) (stroke (width {zone.width}) (type solid)) (fill yes) (uuid {uuid4()})\n')
            f.write('    )\n')

    #转换文本
    #格式: (gr_text "content" (at x y angle) (layer LayerName) (effects ...) (uuid UUID) ...)
    #或:  (fp_text TYPE "content" (at x y angle) (layer LayerName) (hide yes) (effects ...) (uuid UUID))
    #centroid: 所属元件(footprint)的几何中心, =(0,0)为孤立元素
    def _writeText(self, f, text, centroid=(0,0)):
        layer = self.getLayerName(text.layerIdx)
        content = text.text.replace('"', '\\"')
        rotation = sprintAngleToKicad(text.rotation)

        # 镜像的处理比较麻烦, 垂直镜像等价于水平镜像+旋转180
        isMirrored = text.mirrorH
        if text.mirrorV:
            isMirrored = not isMirrored
            rotation = (rotation + 180) % 360

        # KiCad 只有 "justify mirror" (沿X轴水平镜像)
        justify = " (justify mirror)" if isMirrored else ""

        height = r2(text.height)
        x, y = r2(text.pos[0] - centroid[0]), r2(text.pos[1] - centroid[1])
        if centroid == (0,0):
            name = 'gr_text'
            space = '  '
        else:
            name = 'fp_text user'
            space = '    '
        
        f.write(f'{space}({name} "{content}" (at {x} {y} {rotation}) (layer {layer}) (uuid {uuid4()})\n')
        f.write(f'{space}  (effects (font (size {height} {height})){justify})\n')
        f.write(f'{space})\n')

    #转换圆弧
    #格式: (gr_circle (center x y) (end x y) (stroke ...) (layer LayerName) (fill no)...)
    #或: (fp_circle (center x y) (end x y) (stroke ...) (layer LayerName) (fill no)...)
    #或: (gr_arc (start X Y) (mid X Y) (end X Y) (stroke ...) (layer LayerName) (width w)...)
    #或: (fp_arc (start X Y) (mid X Y) (end X Y) (stroke ...) (layer LayerName) (width w)...)
    #centroid: 所属元件(footprint)的几何中心, =(0,0)为孤立元素
    def _writeCircle(self, f, circle, centroid=(0,0)):
        layer = self.getLayerName(circle.layerIdx)
        start = r2(circle.start)
        stop = r2(circle.stop)
        cx, cy = r2(circle.center[0] - centroid[0]), r2(circle.center[1] - centroid[1])
        fill = 'yes' if circle.fill else 'no'
        space = '  ' if centroid == (0,0) else '    '

        # 正圆
        if start == stop:
            endX = r2(cx + circle.radius)
            endY = cy
            name = 'gr_circle' if centroid == (0,0) else 'fp_circle'
            f.write(f'{space}({name} (center {cx} {cy}) (end {endX} {endY}) '
                   f'(stroke (width {r2(circle.width)}) (type solid)) (fill {fill}) '
                 f'(layer {layer}) (uuid {uuid4()}))\n')
        else: # 圆弧
            name = 'gr_arc' if centroid == (0,0) else 'fp_arc'
            start, mid, end = circle.calcStartEndMidPoint()
            start = r2(start[0] - centroid[0]), r2(start[1] - centroid[1])
            mid = r2(mid[0] - centroid[0]), r2(mid[1] - centroid[1])
            end = r2(end[0] - centroid[0]), r2(end[1] - centroid[1])
            f.write(f'{space}({name} (start {start[0]} {start[1]}) (mid {mid[0]} {mid[1]}) (end {end[0]} {end[1]}) '
                   f'(stroke (width {r2(circle.width)}) (type solid)) (fill {fill}) '
                 f'(layer {layer}) (uuid {uuid4()}))\n')

    #元件, 生成一个footprint
    def _writeComponent(self, f, comp):
        centroid = comp.centroid()
        layer = self.getLayerName(comp.getLayer())
        compNo = self.compNo()
        fpId = f"FP_{int(centroid[0] * 100)}_{int(centroid[1] * 100)}_{compNo}"
        f.write(f'  (footprint "{fpId}" (layer "{layer}")\n')
        f.write(f'    (at {r2(centroid[0])} {r2(centroid[1])} 0) (uuid {uuid4()})\n')

        #元件名字
        if comp.namePos:
            nameX, nameY = r2(comp.namePos[0] - centroid[0]), r2(comp.namePos[1] - centroid[1])
        else:
            nameX = nameY = 0
        nameRotation = sprintAngleToKicad(comp.nameRotation) if comp.nameRotation else 0
        nameLayer = self.getLayerName(comp.nameLayer)
        hide = 'no' if comp.nameVisible and comp.compName else 'yes'
        height = r2(comp.txtHeight)
        name = comp.compName if comp.compName else f'CMP{compNo}'
        f.write(f'    (property "Reference" "{name}" (at {nameX} {nameY} {nameRotation})'
            f' (layer "{nameLayer}") (hide {hide}) (uuid {uuid4()}) (effects (font (size {height} {height}) (thickness 0.15))))\n')

        #元件值
        if comp.valuePos:
            valueX, valueY = r2(comp.valuePos[0] - centroid[0]), r2(comp.valuePos[1] - centroid[1])
        else:
            valueX = valueY = 0
        valueRotation = sprintAngleToKicad(comp.valueRotation) if comp.valueRotation else 0
        valueLayer = self.getLayerName(comp.valueLayer)
        hide = 'no' if comp.valueVisible and comp.value else 'yes'
        f.write(f'    (property "Value" "{comp.value}" (at {valueX} {valueY} {valueRotation}) (layer "{valueLayer}")'
            f' (hide {hide}) (uuid {uuid4()}) (effects (font (size {height} {height}) (thickness 0.15))))\n')

        #Footprint (封装源)：表示是从哪个库里的哪个封装来的。比如:Package_SO:SOIC-8_3.9x4.9mm_P1.27mm
        f.write(f'    (property "Footprint" "" (at 0 0 0) (unlocked yes) (layer "{layer.replace(".Cu", ".Fab")}") (hide yes) (uuid {uuid4()}) (effects (font (size 1 1) (thickness 0.15))))\n')
        f.write(f'    (attr {comp.getMountingType()})\n')

        #转换下层元素
        self._processGroup(f, comp, centroid)
        f.write(f'  )\n')

    def writeFooter(self, f):
        f.write(')\n')
